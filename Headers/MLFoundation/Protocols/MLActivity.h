/*
 
 Copyright 2009 undev
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 
 http://www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 
 */

#import <Foundation/Foundation.h>

/** Обобщённый жизненный цикл управлямого асинхронными событиями процесса.
 *
 * TODO, XXX, FIXME и все прочие слова. Здесь (в «старый текст») ненамерено
 * перемешались два понятия: единица конкуренции (в будущем MLActor) и 
 * управляемый процесс (в будущем MLManagedActivity).
 *
 * Позже в рамках имплементации MLManagedActivity эти тексты будут приведены в
 * порядок.
 *
 * \section mlactivity_oldtext Старый текст.
 *
 * Этот жизненный цикл делится на две большие части: сетап и работа. 
 * Сетап должен происходить только по
 * требованию пользователя (запуск программы, новое соединение, запрос 
 * нового потока...) 
 *
 *  - alloc
 *  - init
 *  - установка специфичных для процесса параметров через сеттеры / по KVC
 *
 * Например, ход сетапа MLTCPClientSocket будет примерно такой: alloc, init, 
 * setLoop, setDelegate:, setAddress:, setPort:. 
 *
 * Параметры, нужные для запуска процесса обозначаются через [INIT]. Параметры,
 * нужные обязательно, обозначаются через [MANDATORY].
 *
 *  - validateForStart:(NSError **)error
 *
 * Возвращает YES, если процесс полагает, что у него есть всё, что нужно, чтобы начать
 * с пользой работать или NO, если нет. NO, как правило, означает, что
 * нужно что-то из возвращённого в error написать пользователю и прекратить
 * запускать процесс.
 *
 * Вещи, которые зависят только от программиста, например, то, что 
 * MLTCPClientSocket'у установили event loop, нужно проверять в самом начале
 * метода валидации ассертами.
 *
 * Стоит лишний раз подчеркнуть: то, что validateForStart: вернул YES ещё не
 * означает того, что процесс сделает что-то продуктивное. Оно только гарантирует,
 * что процесс не развалится сразу с ассертом, и обещает, что скорее всего всё
 * получится.
 *
 *  - start
 *  - stop
 *
 *  Начать и прекратить работать, то есть, получать асинхронные сообщения и
 *  что-то с ними делать. 
 *  
 *  Вызов start и stop может захватывать и освобождать какие-то ресурсы; это должно быть
 *  оговорено в описании процеса. В любом случае, эти методы должны быть идемпотентны, 
 *  то есть разрешать вызывать себя по нескольку раз. Некоторые классы могут
 *  имплементировать счётчик стартов.
 *
 *  Процессу запрещается вызывать коллбэки из методов validateForStart,
 *  start, stop и isStarted. Если ему нужно отчитаться об ошибке - стоит использовать
 *  NSObject(MLAsyncMessaging).
 *
 *  Если процесс не запущен, все вызовы ему надлежит терпеливо игнорировать.
 *
 *  Когда процесс запущен, то обычно изменять большую часть его параметров запрещено.
 *  Те, которые можно изменять, обозначены в документации как [RW], прочие -
 *  как [RO]. 
 *
 * Copyright 2009 undev
 */
@protocol MLActivity <NSObject>
/** Проверить готовность процесса к запуску.
 * Возвращает YES, если процесс готов к запуску и NO, если нет. 
 * В последнем случае (и если error не nil) должна выставить autoreleased
 * Error с NSLocalizedDescriptionKey и, возможно, с NSUnderlyingErrorKey.
 *
 * Вообще должна вести себя подобно NSManagedObject'овскому validateForUpdate:, 
 */
- (BOOL)validateForStart:(NSError **)error;

/** Запустить процесс.
 * В ходе выполнения этого метода не должно возникать ошибок.
 * Он даже может делать assert([self validateForStart:nil]).
 * Если они возникли, то должны обрабатываться специфичным для активности
 * асинхронным методом.
 *
 * Если процесс уже запущен - это noop.
 *
 * До вызова start процесс не должен получать никаких событий.
 */
- (void)start;
/** Остановить процесс.
 * Опять-таки, если в ходе останова возникла ошибка, то она должна обрабатываться
 * специфичным для активности асинхронным протоколом.
 *
 * Если процесс не запущен - это noop.
 *
 * После вызова stop процесс не должен получать никаких событий.
 */
- (void)stop;

/** YES, if process running. NO otherwise.*/
- (BOOL)isStarted;
@end

